diff -rNc ../rtptools-1.9/Makefile ./Makefile
*** ../rtptools-1.9/Makefile	Sat Aug  9 23:46:30 1997
--- ./Makefile	Wed Sep  3 13:39:45 1997
***************
*** 45,50 ****
--- 45,51 ----
  WWW    = $(HOME)/html/rtptools
  
  all: dir $(BIN_DIR)/rtpdump \
+      $(BIN_DIR)/rtpmdump \
       $(BIN_DIR)/rtpplay \
       $(BIN_DIR)/rtpsend \
       $(BIN_DIR)/rtptrans
***************
*** 58,63 ****
--- 59,68 ----
  	$(CC) $(CFLAGS) $(OBJ_DIR)/rtpdump.o $(OBJ_DIR)/rd.o $(OBJ) \
      $(LIB_DIR) $(LDFLAGS) $(LDLIBS) -o $@ 
  
+ $(BIN_DIR)/rtpmdump: $(OBJ_DIR)/rtpmdump.o $(OBJ_DIR)/rd.o $(OBJ)
+ 	$(CC) $(CFLAGS) $(OBJ_DIR)/rtpmdump.o $(OBJ_DIR)/rd.o $(OBJ) \
+     $(LIB_DIR) $(LDFLAGS) $(LDLIBS) -o $@ 
+ 
  $(BIN_DIR)/rtpplay: $(OBJ_DIR)/rtpplay.o $(OBJ_DIR)/rd.o $(OBJ) $(HSEARCH_LIB)
  	$(CC) $(CFLAGS) $(OBJ_DIR)/rtpplay.o $(OBJ_DIR)/rd.o $(OBJ) \
      $(LIB_DIR) $(LDFLAGS) $(LDLIBS) $(HSEARCH_LIB) -o $@
***************
*** 90,95 ****
--- 95,103 ----
  
  $(OBJ_DIR)/rtpdump.o: rtpdump.c
  	$(CC) -c $(CFLAGS) $? -o $@
+ 
+ $(OBJ_DIR)/rtpmdump.o: rtpdump.c
+ 	$(CC) -c -DRTPMULTIDUMP $(CFLAGS) $? -o $@
  
  $(OBJ_DIR)/rtpplay.o: rtpplay.c
  	$(CC) -c $(CFLAGS) $? -o $@
diff -rNc ../rtptools-1.9/Makefile.sgi ./Makefile.sgi
*** ../rtptools-1.9/Makefile.sgi	Thu Jan  1 01:00:00 1970
--- ./Makefile.sgi	Wed Sep  3 09:55:05 1997
***************
*** 0 ****
--- 1,4 ----
+ CC		= gcc
+ SYSFLAGS	= -DRTP_BIG_ENDIAN
+ OPT		= -O2
+ LIB_DIR		= -L/local/lib
diff -rNc ../rtptools-1.9/rtpdump.c ./rtpdump.c
*** ../rtptools-1.9/rtpdump.c	Thu Aug  7 19:13:53 1997
--- ./rtpdump.c	Wed Sep  3 13:44:52 1997
***************
*** 27,37 ****
--- 27,53 ----
  * $Id$
  */
  
+ /* RTPMULTIDUMP extension by s.h.huseby@usit.uio.no 1997-09-02
+  *
+  * Define RTPMULTIDUMP either here or on the compiler command line, to
+  * have a version of the program that is able to record several streams
+  * at once.
+  *
+  * NOTE: If you compile using the Makefile that comes with rtptools,
+  *       the Makefile handles the define for you, compiling the program
+  *       rtpmdump with RTPMULTIDUMP enabled. In that case, do _not_
+  *       enable the following #define.
+  */
+ /* #define RTPMULTIDUMP /**/
+ 
  #include <sys/types.h>
  #include <sys/socket.h>
  #include <netinet/in.h>  /* struct sockaddr_in */
  #include <arpa/inet.h>   /* inet_ntoa() */
  #include <sys/time.h>    /* gettimeofday() */
+ #ifdef RTPMULTIDUMP
+ #include <sys/wait.h>
+ #endif
  #include <string.h>
  #include <stdio.h>
  #include <signal.h>
***************
*** 67,75 ****
--- 83,99 ----
  
  static void usage(char *argv0)
  {
+ #ifdef RTPMULTIDUMP
+     fprintf(stderr,
+ 	    "Usage: %s [-F [hex|ascii|rtcp|short|payload|dump|header] "
+ 	    "[-t minutes] [-b bytes] "
+ 	    "[multicast]/port outfile [[multicast]/port outfile ...]\n",
+ 	    argv0);
+ #else
    fprintf(stderr, 
  "Usage: %s [-F [hex|ascii|rtcp|short|payload|dump|header] [-t minutes] [-b bytes] [multicast]/port > file\n", 
    argv0);
+ #endif
  }
  
  
***************
*** 78,83 ****
--- 102,122 ----
    exit(0);
  }
  
+ #ifdef RTPMULTIDUMP
+ static void exit_all(int retval, const char *msg)
+ {
+   fprintf(stderr, "%s", msg);
+   /* terminate children (and self, hopefully) */
+   kill(-getpid(), SIGINT);
+   exit(retval);
+ }
+ 
+ static void parent_done(int s)
+ {
+   exit_all(0, "terminating children...\n");
+ }
+ #endif
+ 
  static double tdbl(struct timeval *a)
  {
    return a->tv_sec + a->tv_usec/1e6;
***************
*** 576,581 ****
--- 615,623 ----
    int i;
    int nfds = 0;
    extern double tdbl(struct timeval *);
+ #ifdef RTPMULTIDUMP
+   int is_parent = 1;
+ #endif
  
    while ((c = getopt(argc, argv, "b:F:f:t:x:")) != EOF) {
      switch(c) {
***************
*** 664,669 ****
--- 706,749 ----
    timeout.tv_usec = 0;
    timeout.tv_sec  = duration;
  
+ #ifdef RTPMULTIDUMP
+   /* if no arguments left, show usage information. */
+   if (optind == argc || ((argc - optind) % 2) != 0)
+     usage(argv[0]);
+ 
+   /* fork children for each pair of address and filename. */
+   while (optind < argc) {
+     int pid;
+ 
+     if ((pid = fork()) == -1)
+       exit_all(1, "fork error\n");
+     else if (pid > 0) {
+       /* parent */
+       optind += 2;
+     } else {
+       /* child */
+       is_parent = 0;
+       source = FromNetwork;
+       nfds = open_network(argv[optind], format != F_rtcp, sock, &sin);
+       freopen(argv[optind + 1], "wb", stdout);
+       gettimeofday(&start, 0);
+       dstart = tdbl(&start);
+       break;
+     }
+   }
+ 
+   if (is_parent) {
+     /* the parent is put to sleep untill all children die. */
+     int err, waitstat;
+ 
+     signal(SIGINT, parent_done);
+     do {
+       err = wait(&waitstat);
+     } while (!(err == -1 && errno == ECHILD));
+     exit(0);
+   }
+ 
+ #else
    /* if no optional arguments, we are reading from a file */
    if (optind == argc) {
      source = FromFile;
***************
*** 678,683 ****
--- 758,764 ----
      gettimeofday(&start, 0);
      dstart = tdbl(&start);
    }
+ #endif
  
    /* write header for dump file */
    if (format == F_dump || format == F_header)

